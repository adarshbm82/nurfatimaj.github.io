---
# Documentation: https://sourcethemes.com/academic/docs/managing-content/

title: "Covid-19 in Italy in graphs"
subtitle: ""
summary: " "
authors: [admin]
tags: []
categories: []
date: 2020-03-25T15:00:08+01:00
lastmod: 2020-03-25T15:00:08+01:00
featured: false
draft: false

# Featured image
# To use, add an image named `featured.jpg/png` to your page's folder.
# Focal points: Smart, Center, TopLeft, Top, TopRight, Left, Right, BottomLeft, Bottom, BottomRight.
image:
  caption: ""
  focal_point: ""
  preview_only: false

# Projects (optional).
#   Associate this post with one or more of your projects.
#   Simply enter your project's folder or file name without extension.
#   E.g. `projects = ["internal-project"]` references `content/project/deep-learning/index.md`.
#   Otherwise, set `projects = []`.
projects: []
---

Dataset source: [github repository of the Department of Civil Protection](https://github.com/pcm-dpc/COVID-19)

## Setup
```{r message=FALSE}
library(tidyverse)
library(lubridate)

data_file <- 'data/dati-regioni/dpc-covid19-ita-regioni.csv'

df <- read_csv(data_file)
```

It is also helpful to reorder the regions based on north-south scale.

```{r}
df <- df %>% mutate(distance = sqrt(lat^2 + long^2),
                    regions = fct_reorder(denominazione_regione, desc(distance)))
```

Since the hour information is useless, let's remove it

```{r}
df <- df %>% mutate(date = date(data)) %>% select(-data)
```

And some settings for the plots
```{r}
theme_set(theme_minimal())
theme_update(legend.position = 'bottom')
options(ggplot2.continuous.colour = 'Spectral')
options(ggplot2.continuous.fill = 'Spectral')
myColourPalette <- c('#67001f','#b2182b','#d6604d','#f4a582','#fddbc7','#f7f7f7','#d1e5f0','#92c5de','#4393c3','#2166ac',
                     '#053061', 'white', '#40004b','#762a83','#9970ab','#c2a5cf','#e7d4e8','#f7f7f7','#d9f0d3','#a6dba0',
                     '#5aae61','#1b7837','#00441b') #from colorbrewer2.org
```

## Plots
### Testing activity and new cases
If we were able to test everyone in the population, the only thing we needed to do to get a sense of infection rate is to divide number of positive cases by the population. Unfortunately, there are not enough tests. The capacity to identify confirm cases is limited by the testing capacity; therefore, it helps to look at both testing and positive cases simultaneously, whether in absolute or relative terms.

```{r}
df %>% select(date, regions, tamponi, nuovi_positivi) %>%
  group_by(regions) %>%
  arrange(date) %>%
  mutate(new_tests = tamponi - lag(tamponi, 1)) %>%
  ungroup() %>% select(-tamponi) %>%
  gather(key = 'variable', value = 'value', -regions, -date) %>%
  mutate(variable = ifelse(variable == 'new_tests', 'New tests', 'New positive cases')) %>%
  ggplot(., aes(x = date, y = value/1000, colour = variable)) + geom_point() + geom_line() +
  facet_wrap(~regions, scales = 'free_y') +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(x = 'Date', y = 'thousands', colour = '') +
  scale_colour_brewer(palette = 'Set1')
```

If random subset of population was tested for the virus, then dividing the number of positive cases by the number of people tested would have also given a good statistic for infection rate.

```{r}
df %>% mutate(positive_share = totale_positivi/tamponi) %>%
  ggplot(., aes(x = date, y = positive_share*100, colour = 'Positive cases as a share of total tested')) +
  geom_point() + geom_line() +
  facet_wrap(~regions, scales = 'free_y') +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(x = 'Date', y = '%')
```

```{r}
df %>% 
  ggplot(., aes(x = date, y = nuovi_positivi, fill = regions)) + 
  geom_bar(position = 'stack', stat = 'identity') + 
  scale_fill_manual(values = myColourPalette)
```


Unfortunately, tests are unlikely to have been given randomly, giving rise to selection issues. When we see that positive cases are on the rise (even if divided by the total number of people tested), this could be that

- more people are getting infected, or
- tests are given to those most likely to have the virus.


### Death rate and new death cases
```{r}
df %>% mutate(death_rate = deceduti/totale_casi) %>%
  ggplot(., aes(x = date, y = death_rate*100, colour = 'Death rate')) + geom_point() + geom_line() +
  facet_wrap(~regions, scales = 'fixed') +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(x = 'Date', y = '%', colour = '')
```

```{r}
df %>% group_by(regions) %>% arrange(date) %>%
  mutate(new_death = deceduti - lag(deceduti, 1)) %>%
  ungroup() %>%
  ggplot(., aes(x = date, y = new_death, fill = regions)) + geom_bar(position = 'stack', stat = 'identity') +
  scale_fill_manual(values = myColourPalette) +
  labs(x = 'Date', y = 'New death cases', fill = 'Regions')
ggsave(filename = 'featured.png')
```

### Timeline on a map
To view the timeline of death_rate on a map, I need to create the indicator first. There are some observations where both number of deaths and total cases are 0, resulting in NaN death rate. I substitute these with 0. 

The code for interactive animated map is borrowed from 

- [Using Leaflet with Shiny](https://rstudio.github.io/leaflet/shiny.html)
- [Embedding a shiny app in blogdown](https://www.brettory.com/2018/02/embedding-a-shiny-app-in-blogdown/)

```{r eval=FALSE}
shinyApp(
  bootstrapPage(
    tags$style(type = "text/css", "html, body {width:100%;height:100%; background:rgb(255,255,255)}"),
    leafletOutput("map", width = "100%", height = "100%"),
    absolutePanel(top = 10, right = 10,
                  sliderInput("range", "Date", 
                              min = min(df$date), 
                              max = max(df$date),
                              value = max(df$date), 
                              step = 1, 
                              animate = TRUE), 
                  selectInput("colors", "Color Scheme",
                              #rownames(subset(brewer.pal.info, category %in% c("seq", "div")))
                              c('Spectral', 'RdBu', 'Blues', 'Greens', 'Reds')),
                  checkboxInput("legend", "Show legend", TRUE))), 
  server <- function(input, output) {
    #stuff in server
    filteredData <- reactive({
      df[df$date == input$range[1], ]
    })
    
    # This reactive expression represents the palette function,
    # which changes as the user makes selections in UI.
    colorpal <- reactive({
      colorNumeric(input$colors, df$death_rate)
    })
    
    output$map <- renderLeaflet({
      # Use leaflet() here, and only include aspects of the map that
      # won't need to change dynamically (at least, not unless the
      # entire map is being torn down and recreated).
      leaflet(df) %>% addTiles() %>%
        addProviderTiles(providers$CartoDB.Positron) %>% 
        fitBounds(~min(long), ~min(lat), ~max(long), ~max(lat))
    })
    
    # Incremental changes to the map (in this case, replacing the
    # circles when a new color is chosen) should be performed in
    # an observer. Each independent set of things that can change
    # should be managed in its own observer.
    observe({
      pal <- colorpal()
      
      leafletProxy("map", data = filteredData()) %>%
        clearMarkers() %>%
        addCircleMarkers(lng = ~long, lat = ~lat, 
                         radius = ~death_rate, 
                         color = ~pal(death_rate), 
                         popup = ~paste(death_rate))
    })
    
    # Use a separate observer to recreate the legend as needed.
    observe({
      proxy <- leafletProxy("map", data = df)
      
      # Remove any existing legend, and only if the legend is
      # enabled, create a new one.
      proxy %>% clearControls()
      if (input$legend) {
        pal <- colorpal()
        proxy %>% addLegend(position = "bottomright", pal = pal, values = ~death_rate)
      }
    })
    
  },
  options = list(height = 500, width = '100%')
)
```

<iframe width="100%" height="500" src="https://nurfatimaj.shinyapps.io/covid-19/"></iframe>

